using MatcherWebApi.Enumerators;
using MatcherWebApi.Interfaces;
using System.Collections.Generic;
using System.Linq;

namespace MatcherWebApi.Classes
{
    public class OrderManager : IOrderManager
    {
        #region Private Declarations

        private IList<IOrder> orderHistory = null;
        private IList<IOrder> marketOrders = null;
        private IList<IOrderGroup> aggregateOrders = null;
        private IList<IOrderGroup> cumulativeOrders = null;

        #endregion Private Declarations

        #region Public Properties

        /// <summary>
        /// List of all orders placed.
        /// </summary>
        public IList<IOrder> OrderHistory
        {
            get => orderHistory ?? (orderHistory = new List<IOrder>());
            set => orderHistory = value;
        }

        /// <summary>
        /// List of available orders in the market place.
        /// </summary>
        public IList<IOrder> MarketOrders
        {
            get => marketOrders ?? (marketOrders = new List<IOrder>());
            set => marketOrders = value;
        }

        /// <summary>
        /// List of aggregate orders at a particular price.
        /// </summary>
        public IList<IOrderGroup> AggregateOrders
        {
            get => GetAggregateOrders(MarketOrders);
            set => aggregateOrders = value;
        }

        /// <summary>
        /// List of cumulative orders at a particular price.
        /// </summary>
        public IList<IOrderGroup> CumulativeOrders
        {
            get => GetCumulativeOrders(AggregateOrders);
            set => cumulativeOrders = value;
        }

        #endregion Public Properties

        #region Constructors

        /// <summary>
        /// Constructor of the OrderManager class.
        /// </summary>
        public OrderManager()
        { }


        #endregion Constructors

        #region Methods

        /// <summary>
        /// Find a match for the order.
        /// </summary>
        /// <param name="newOrder">The order to match.</param>
        /// <returns>A matching order if it exists.</returns>
        public IOrder MatchOrder(IOrder newOrder)
        {
            foreach (var item in MarketOrders.Where(o => o.OrderType != newOrder.OrderType))
            {
                if (newOrder.OrderType == OrderType.BUY)
                {
                    if (item.Price <= newOrder.Price)
                    {
                        return item;
                    }
                }
                else
                {
                    if (item.Price >= newOrder.Price)
                    {
                        return item;
                    }
                }
            }

            return null;
        }

        /// <summary>
        /// Place the order.
        /// </summary>
        /// <param name="account">The account of the new order.</param>
        /// <param name="quantity">The quantity of the new order.</param>
        /// <param name="price">The price of the new order.</param>
        /// <param name="orderType">The order type of the new order.</param>
        /// <returns>A list of trades generated by the new order.</returns>
        public IList<ITrade> PlaceOrder(IAccount account, int quantity, decimal price, OrderType orderType)
        {
            return PlaceOrder(new Order(account, quantity, price, orderType));
        }

        /// <summary>
        /// Place the order.
        /// </summary>
        /// <param name="newOrder">The new order to place.</param>
        /// <returns>A list of trades generated by the new order.</returns>
        public IList<ITrade> PlaceOrder(IOrder newOrder)
        {
            //Add a copy of the order to the order history.
            OrderHistory.Add(newOrder.Clone);

            //Process the order.
            return ProcessOrder(newOrder);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="newOrder"></param>
        /// <returns></returns>
        private IList<ITrade> ProcessOrder(IOrder newOrder)
        {
            IList<ITrade> result = new List<ITrade>();

            while (newOrder.Quantity.Value > 0)
            {
                IOrder existingOrder = MatchOrder(newOrder);

                if (existingOrder != null)
                {
                    //A match exists create the trade.
                    result.Add(CreateTrade(newOrder, existingOrder));
                }
                else
                {
                    //No match, ddd the order to the Market Orders
                    MarketOrders.Add(newOrder);
                    break;
                }
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="newOrder"></param>
        /// <param name="existingOrder"></param>
        /// <returns></returns>
        private ITrade CreateTrade(IOrder newOrder, IOrder existingOrder)
        {
            ITrade trade = new Trade(newOrder.Clone, existingOrder.Clone);

            //Adjust the orders for the trade.
            if (trade.Quantity.Value >= existingOrder.Quantity.Value)
            {
                MarketOrders.Remove(existingOrder);
                newOrder.Quantity -= trade.Quantity.Value;
            }
            else
            {
                existingOrder.Quantity -= trade.Quantity.Value;
            }

            return trade;
        }

        #endregion Methods


        /// <summary>
        /// 
        /// </summary>
        /// <param name="orders"></param>
        /// <returns></returns>
        private IList<IOrderGroup> GetAggregateOrders(IList<IOrder> orders)
        {
            IList<IOrderGroup> result = new List<IOrderGroup>();

            foreach (var order in orders)
            {
                IOrderGroup aggregateOrder = result.Single(x => x.Price == order.Price && x.OrderType == order.OrderType);

                if (aggregateOrder == null)
                {
                    aggregateOrder = new AggregateOrder(order.Price.Value, order.OrderType.Value);
                }

                aggregateOrder.Add(order);
            }

            return result;
        }

        private IList<IOrderGroup> GetCumulativeOrders(IList<IOrderGroup> aggregateOrders)
        {
            return GetCumulativeOrdersBuy(aggregateOrders).Union(GetCumulativeOrdersSell(aggregateOrders)).ToList();
        }

        private IList<IOrderGroup> GetCumulativeOrdersBuy(IList<IOrderGroup> aggregateOrders)
        {
            IList<IOrderGroup> results = new List<IOrderGroup>();

            foreach (var orderGroup in aggregateOrders.Where(o => o.OrderType == OrderType.BUY))
            {
                results.Add(new OrderGroup(orderGroup.Price.Value, orderGroup.OrderType.Value));

                foreach (var result in results)
                {
                    if (result.Price.Value <= orderGroup.Price.Value)
                    {
                        result.Add(orderGroup.Orders);
                    }
                }
            }

            return results;
        }

        private IList<IOrderGroup> GetCumulativeOrdersSell(IList<IOrderGroup> aggregateOrders)
        {
            IList<IOrderGroup> results = new List<IOrderGroup>();

            foreach (var orderGroup in aggregateOrders.Where(o => o.OrderType == OrderType.SELL).OrderByDescending(o => o.Price))
            {
                results.Add(new OrderGroup(orderGroup.Price.Value, orderGroup.OrderType.Value));

                foreach (var result in results)
                {
                    if (result.Price.Value >= orderGroup.Price.Value)
                    {
                        result.Add(orderGroup.Orders);
                    }
                }
            }

            return results;
        }
    }
}